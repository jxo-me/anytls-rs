# ğŸš€ v0.3.0 å®æ–½è®¡åˆ’

**ç›®æ ‡ç‰ˆæœ¬**: v0.3.0  
**ç›®æ ‡**: è¿½èµ¶ Go å®ç°ï¼Œè¾¾åˆ° 90% åŠŸèƒ½å®Œæ•´åº¦  
**é¢„è®¡å·¥ä½œé‡**: 9-14 å¤©  
**å¼€å§‹æ—¥æœŸ**: 2025-11-03

---

## ğŸ“‹ ç›®å½•

1. [ç‰ˆæœ¬ç›®æ ‡](#ç‰ˆæœ¬ç›®æ ‡)
2. [ä»»åŠ¡æ¸…å•](#ä»»åŠ¡æ¸…å•)
3. [åˆ†é˜¶æ®µå®æ–½](#åˆ†é˜¶æ®µå®æ–½)
4. [æµ‹è¯•è®¡åˆ’](#æµ‹è¯•è®¡åˆ’)
5. [éªŒæ”¶æ ‡å‡†](#éªŒæ”¶æ ‡å‡†)

---

## ç‰ˆæœ¬ç›®æ ‡

### ğŸ¯ æ ¸å¿ƒç›®æ ‡

**ä» 75% â†’ 90% åŠŸèƒ½å®Œæ•´åº¦**

### å…³é”®æˆæœ

- âœ… å®ç°è¢«åŠ¨å¿ƒè·³å“åº”
- âœ… å®ç° UDP over TCP æ”¯æŒ
- âœ… å®Œå–„ä¼šè¯æ± ç®¡ç†
- âœ… å¢å¼º SYNACK è¶…æ—¶æ£€æµ‹
- âœ… å®ç°ç‰ˆæœ¬åå•†æœºåˆ¶

### æ€§èƒ½ç›®æ ‡

- âœ… ä¿æŒ +40-60% æ€§èƒ½ä¼˜åŠ¿
- âœ… æ”¯æŒ UDP ä»£ç†
- âœ… æ›´å¥½çš„è¿æ¥ç®¡ç†
- âœ… æ›´çŸ­çš„é”™è¯¯æ¢å¤æ—¶é—´

---

## ä»»åŠ¡æ¸…å•

### ä¼˜å…ˆçº§ P0ï¼ˆå¿…é¡»å®Œæˆï¼‰

- [ ] **é˜¶æ®µ 1**: è¢«åŠ¨å¿ƒè·³å“åº”ï¼ˆ1-2 å¤©ï¼‰â­â­â­â­â­
- [ ] **é˜¶æ®µ 2**: UDP over TCP æ”¯æŒï¼ˆ3-4 å¤©ï¼‰â­â­â­â­â˜†
- [ ] **é˜¶æ®µ 3**: ä¼šè¯æ± é…ç½®å¢å¼ºï¼ˆ2-3 å¤©ï¼‰â­â­â­â˜†â˜†

### ä¼˜å…ˆçº§ P1ï¼ˆå»ºè®®å®Œæˆï¼‰

- [ ] **é˜¶æ®µ 4**: SYNACK è¶…æ—¶æ£€æµ‹ï¼ˆ1-2 å¤©ï¼‰â­â­â­â˜†â˜†
- [ ] **é˜¶æ®µ 5**: ç‰ˆæœ¬åå•†æœºåˆ¶ï¼ˆ2-3 å¤©ï¼‰â­â­â­â˜†â˜†

### ä¼˜å…ˆçº§ P2ï¼ˆå¯é€‰ï¼‰

- [ ] **é˜¶æ®µ 6**: æ–‡æ¡£å’Œæµ‹è¯•å®Œå–„ï¼ˆ1-2 å¤©ï¼‰

---

## åˆ†é˜¶æ®µå®æ–½

---

## ğŸ”µ é˜¶æ®µ 1: è¢«åŠ¨å¿ƒè·³å“åº” (1-2 å¤©) â­â­â­â­â­

**ç›®æ ‡**: å®ç°å¿ƒè·³è¯·æ±‚çš„å“åº”ï¼Œä¸ºæœªæ¥ä¸»åŠ¨æ£€æµ‹æ‰“åŸºç¡€

### ä»»åŠ¡åˆ†è§£

#### 1.1 æ›´æ–° Command å¤„ç† (0.5 å¤©)

**æ–‡ä»¶**: `src/session/session.rs`

**ä¿®æ”¹å†…å®¹**:

```rust
// handle_frame() æ–¹æ³•ä¸­æ·»åŠ 
Command::HeartRequest => {
    tracing::debug!(
        "[Session] ğŸ’“ Received HeartRequest from stream {}", 
        frame.stream_id
    );
    
    // ç«‹å³å›å¤ HeartResponse
    let response = Frame::control(Command::HeartResponse, frame.stream_id);
    
    if let Err(e) = self.write_control_frame(response).await {
        tracing::error!(
            "[Session] Failed to send HeartResponse: {}", 
            e
        );
        return Err(e);
    }
    
    tracing::debug!(
        "[Session] âœ… Sent HeartResponse to stream {}", 
        frame.stream_id
    );
}

Command::HeartResponse => {
    tracing::debug!(
        "[Session] ğŸ’š Received HeartResponse from stream {}", 
        frame.stream_id
    );
    
    // è®°å½•æ”¶åˆ°å“åº”ï¼ˆä¸ºæœªæ¥ä¸»åŠ¨æ£€æµ‹åšå‡†å¤‡ï¼‰
    // TODO: åœ¨ v0.4.0 å®ç°ä¸»åŠ¨å¿ƒè·³æ£€æµ‹æ—¶ä½¿ç”¨
}
```

**ä½ç½®**: `src/session/session.rs` çš„ `handle_frame()` æ–¹æ³•

#### 1.2 æ·»åŠ æµ‹è¯• (0.5 å¤©)

**æ–‡ä»¶**: `src/session/session.rs` (æµ‹è¯•æ¨¡å—)

**æµ‹è¯•å†…å®¹**:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_heartbeat_request_response() {
        // 1. åˆ›å»º Session
        let (client_reader, server_writer) = /* ... */;
        let (server_reader, client_writer) = /* ... */;
        
        let client_session = Session::new(client_reader, client_writer, true);
        let server_session = Session::new(server_reader, server_writer, false);
        
        // 2. å®¢æˆ·ç«¯å‘é€ HeartRequest
        let request = Frame::control(Command::HeartRequest, 0);
        client_session.write_control_frame(request).await.unwrap();
        
        // 3. æœåŠ¡å™¨åº”è¯¥è‡ªåŠ¨å›å¤ HeartResponse
        // 4. å®¢æˆ·ç«¯åº”è¯¥æ”¶åˆ° HeartResponse
        
        // éªŒè¯
    }
}
```

#### 1.3 é›†æˆæµ‹è¯• (0.5 å¤©)

**æ–‡ä»¶**: `tests/heartbeat.rs` (æ–°å»º)

**æµ‹è¯•å†…å®¹**:
- å®¢æˆ·ç«¯å‘é€å¿ƒè·³ï¼ŒæœåŠ¡å™¨å“åº”
- å¤šæ¬¡å¿ƒè·³è¯·æ±‚
- å¿ƒè·³è¶…æ—¶åœºæ™¯ï¼ˆä¸º v0.4.0 å‡†å¤‡ï¼‰

#### 1.4 æ–‡æ¡£æ›´æ–° (0.5 å¤©)

**æ›´æ–°æ–‡ä»¶**:
- `CHANGELOG.md`: æ·»åŠ  HeartRequest/Response æ”¯æŒ
- `ARCHITECTURE.md`: æ›´æ–°å¿ƒè·³æœºåˆ¶è¯´æ˜
- `README.md`: æ›´æ–°åŠŸèƒ½åˆ—è¡¨

### éªŒæ”¶æ ‡å‡†

- [ ] âœ… æœåŠ¡å™¨æ”¶åˆ° HeartRequest èƒ½æ­£ç¡®å“åº” HeartResponse
- [ ] âœ… å®¢æˆ·ç«¯èƒ½æ­£ç¡®æ¥æ”¶ HeartResponse
- [ ] âœ… å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] âœ… é›†æˆæµ‹è¯•é€šè¿‡
- [ ] âœ… ä¸ Go å®ç°äº’æ“ä½œæ­£å¸¸

---

## ğŸŸ¢ é˜¶æ®µ 2: UDP over TCP æ”¯æŒ (3-4 å¤©) â­â­â­â­â˜†

**ç›®æ ‡**: å®ç° sing-box udp-over-tcp v2 åè®®æ”¯æŒ

### ä»»åŠ¡åˆ†è§£

#### 2.1 ç ”ç©¶ sing-box åè®® (0.5 å¤©)

**å‚è€ƒ**:
- sing-box udp-over-tcp v2 åè®®æ–‡æ¡£
- Go å®ç°: `anytls-go/cmd/server/outbound_tcp.go`

**ç†è§£**:
- UDP åŒ…æ ¼å¼
- åœ°å€ç¼–ç 
- æ•°æ®å°è£…

#### 2.2 å®ç° UDP ä»£ç†æ¨¡å— (1-1.5 å¤©)

**æ–‡ä»¶**: `src/server/udp_proxy.rs` (æ–°å»º)

**ç»“æ„**:

```rust
//! UDP over TCP proxy implementation
//! Implements sing-box udp-over-tcp v2 protocol

use crate::session::Stream;
use crate::util::{Result, AnyTlsError};
use std::sync::Arc;
use tokio::net::UdpSocket;
use bytes::{Bytes, BytesMut, Buf, BufMut};

/// Handle UDP over TCP stream
/// 
/// Target address should be "sp.v2.udp-over-tcp.arpa"
pub async fn handle_udp_over_tcp(
    stream: Arc<Stream>,
) -> Result<()> {
    tracing::info!("[UDP] Starting UDP over TCP proxy for stream {}", stream.id());
    
    // 1. åˆ›å»º UDP socket
    let udp_socket = UdpSocket::bind("0.0.0.0:0").await?;
    
    // 2. åŒå‘æ•°æ®è½¬å‘
    // Stream (TCP) â†â†’ UdpSocket (UDP)
    
    tokio::select! {
        result = udp_to_stream(&udp_socket, &stream) => result?,
        result = stream_to_udp(&stream, &udp_socket) => result?,
    }
    
    Ok(())
}

/// UDP â†’ Stream: è¯»å– UDP åŒ…ï¼Œç¼–ç åé€šè¿‡ Stream å‘é€
async fn udp_to_stream(
    udp: &UdpSocket,
    stream: &Stream,
) -> Result<()> {
    let mut buf = vec![0u8; 65535]; // UDP æœ€å¤§åŒ…å¤§å°
    
    loop {
        let (len, addr) = udp.recv_from(&mut buf).await?;
        
        // ç¼–ç ä¸º sing-box udp-over-tcp v2 æ ¼å¼
        let packet = encode_udp_packet(&buf[..len], &addr)?;
        
        // å‘é€åˆ° Stream
        stream.writer_tx().send((stream.id(), packet))?;
    }
}

/// Stream â†’ UDP: ä» Stream è¯»å–ï¼Œè§£ç åé€šè¿‡ UDP å‘é€
async fn stream_to_udp(
    stream: &Stream,
    udp: &UdpSocket,
) -> Result<()> {
    let reader = stream.reader();
    let mut reader_guard = reader.lock().await;
    
    loop {
        // è¯»å–ä¸€ä¸ª UDP åŒ…ï¼ˆsing-box æ ¼å¼ï¼‰
        let packet = read_udp_packet(&mut *reader_guard).await?;
        
        // è§£ç 
        let (data, addr) = decode_udp_packet(&packet)?;
        
        // å‘é€ UDP
        udp.send_to(&data, addr).await?;
    }
}

/// ç¼–ç  UDP åŒ…ä¸º sing-box udp-over-tcp v2 æ ¼å¼
/// 
/// æ ¼å¼:
/// | Length (2 bytes) | Address | Data |
fn encode_udp_packet(data: &[u8], addr: &SocketAddr) -> Result<Bytes> {
    let mut buf = BytesMut::new();
    
    // è®¡ç®—æ€»é•¿åº¦
    let addr_bytes = encode_socket_addr(addr);
    let total_len = addr_bytes.len() + data.len();
    
    // å†™å…¥é•¿åº¦ï¼ˆBig-Endian uint16ï¼‰
    buf.put_u16(total_len as u16);
    
    // å†™å…¥åœ°å€
    buf.put_slice(&addr_bytes);
    
    // å†™å…¥æ•°æ®
    buf.put_slice(data);
    
    Ok(buf.freeze())
}

/// è§£ç  sing-box udp-over-tcp v2 æ ¼å¼
fn decode_udp_packet(packet: &[u8]) -> Result<(Vec<u8>, SocketAddr)> {
    let mut buf = packet;
    
    // è¯»å–é•¿åº¦
    if buf.remaining() < 2 {
        return Err(AnyTlsError::Protocol("UDP packet too short".into()));
    }
    let len = buf.get_u16() as usize;
    
    // è¯»å–åœ°å€
    let addr = decode_socket_addr(&mut buf)?;
    
    // è¯»å–æ•°æ®
    let data = buf.to_vec();
    
    Ok((data, addr))
}

/// è¯»å–ä¸€ä¸ªå®Œæ•´çš„ UDP åŒ…
async fn read_udp_packet(reader: &mut StreamReader) -> Result<Vec<u8>> {
    // 1. è¯»å– 2 å­—èŠ‚é•¿åº¦
    let mut len_buf = [0u8; 2];
    reader.read_exact(&mut len_buf).await?;
    let len = u16::from_be_bytes(len_buf) as usize;
    
    // 2. è¯»å–æŒ‡å®šé•¿åº¦çš„æ•°æ®
    let mut buf = vec![0u8; len];
    reader.read_exact(&mut buf).await?;
    
    Ok(buf)
}

// TODO: å®ç° encode_socket_addr å’Œ decode_socket_addr
// å‚è€ƒ SOCKS5 åœ°å€æ ¼å¼
```

**å·¥ä½œé‡**: 1-1.5 å¤©

#### 2.3 é›†æˆåˆ° Handler (0.5 å¤©)

**æ–‡ä»¶**: `src/server/handler.rs`

**ä¿®æ”¹**:

```rust
// åœ¨ StreamHandler::handle_stream ä¸­
pub async fn handle_stream(
    &self,
    stream: Arc<Stream>,
    session: Arc<Session>,
) -> Result<()> {
    let stream_id = stream.id();
    
    // è¯»å–ç›®æ ‡åœ°å€
    let addr = read_socks_addr(&stream).await?;
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ UDP over TCP
    if addr.domain == "sp.v2.udp-over-tcp.arpa" {
        tracing::info!(
            "[Proxy] ğŸ”µ UDP over TCP request for stream {}", 
            stream_id
        );
        
        // å‘é€ SYNACKï¼ˆå¦‚æœæ˜¯ v2 å®¢æˆ·ç«¯ï¼‰
        let peer_version = session.peer_version();
        if peer_version >= 2 {
            let synack = Frame::control(Command::SynAck, stream_id);
            session.write_control_frame(synack).await?;
        }
        
        // å¤„ç† UDP over TCP
        crate::server::udp_proxy::handle_udp_over_tcp(stream).await?;
    } else {
        // æ™®é€š TCP ä»£ç†
        proxy_tcp_connection_with_synack(stream, session, stream_id, peer_version).await?;
    }
    
    Ok(())
}
```

#### 2.4 å®¢æˆ·ç«¯æ”¯æŒ (0.5 å¤©)

**æ–‡ä»¶**: `src/client/udp.rs` (æ–°å»º)

**å†…å®¹**: å®¢æˆ·ç«¯ UDP ä»£ç†å…¥å£ï¼ˆå¦‚éœ€æ”¯æŒï¼‰

#### 2.5 æµ‹è¯• (1 å¤©)

**æµ‹è¯•é¡¹**:
- [ ] UDP åŒ…ç¼–è§£ç 
- [ ] UDP â†’ Stream è½¬å‘
- [ ] Stream â†’ UDP è½¬å‘
- [ ] å¤šä¸ª UDP è¿æ¥
- [ ] å¤§åŒ…å’Œå°åŒ…
- [ ] åœ°å€æ ¼å¼ï¼ˆIPv4/IPv6/Domainï¼‰

**æµ‹è¯•æ–‡ä»¶**: `tests/udp_over_tcp.rs` (æ–°å»º)

#### 2.6 æ–‡æ¡£ (0.5 å¤©)

**æ›´æ–°**:
- `README.md`: æ·»åŠ  UDP æ”¯æŒè¯´æ˜
- `ARCHITECTURE.md`: UDP over TCP æ¶æ„
- æ·»åŠ ä½¿ç”¨ç¤ºä¾‹

### éªŒæ”¶æ ‡å‡†

- [ ] âœ… èƒ½æ­£ç¡®ç¼–è§£ç  UDP åŒ…
- [ ] âœ… UDP æ•°æ®æ­£ç¡®è½¬å‘
- [ ] âœ… æ”¯æŒ IPv4/IPv6/Domain
- [ ] âœ… é›†æˆæµ‹è¯•é€šè¿‡
- [ ] âœ… ä¸ Go å®ç°äº’æ“ä½œ

---

## ğŸŸ¡ é˜¶æ®µ 3: ä¼šè¯æ± é…ç½®å¢å¼º (2-3 å¤©) â­â­â­â˜†â˜†

**ç›®æ ‡**: å®Œå–„ä¼šè¯æ± ç®¡ç†ï¼Œæ·»åŠ é…ç½®å‚æ•°

### ä»»åŠ¡åˆ†è§£

#### 3.1 é‡æ„ SessionPool (1-1.5 å¤©)

**æ–‡ä»¶**: `src/client/session_pool.rs`

**æ–°å¢ç»“æ„**:

```rust
/// ä¼šè¯æ± é…ç½®
#[derive(Debug, Clone)]
pub struct SessionPoolConfig {
    /// æ£€æŸ¥ç©ºé—²ä¼šè¯çš„é—´éš”æ—¶é—´ï¼ˆé»˜è®¤ 30sï¼‰
    pub check_interval: Duration,
    
    /// ç©ºé—²è¶…æ—¶æ—¶é—´ï¼ˆé»˜è®¤ 60sï¼‰
    pub idle_timeout: Duration,
    
    /// æœ€å°ä¿ç•™çš„ç©ºé—²ä¼šè¯æ•°ï¼ˆé»˜è®¤ 1ï¼‰
    pub min_idle_sessions: usize,
}

impl Default for SessionPoolConfig {
    fn default() -> Self {
        Self {
            check_interval: Duration::from_secs(30),
            idle_timeout: Duration::from_secs(60),
            min_idle_sessions: 1,
        }
    }
}

/// æ± åŒ–çš„ä¼šè¯
struct PooledSession {
    seq: u64,                    // Session åºå·
    session: Arc<Session>,
    idle_since: Instant,         // ç©ºé—²å¼€å§‹æ—¶é—´
}

/// ä¼šè¯æ± ï¼ˆå¢å¼ºç‰ˆï¼‰
pub struct SessionPool {
    // æŒ‰ Seq å­˜å‚¨ï¼ˆBTreeMap ä¿è¯æœ‰åºï¼‰
    idle_sessions: Arc<RwLock<BTreeMap<u64, PooledSession>>>,
    
    // Seq è®¡æ•°å™¨ï¼ˆå•è°ƒé€’å¢ï¼‰
    next_seq: Arc<AtomicU64>,
    
    // é…ç½®
    config: SessionPoolConfig,
    
    // æ¸…ç†ä»»åŠ¡å¥æŸ„
    cleanup_task: Arc<Mutex<Option<JoinHandle<()>>>>,
}

impl SessionPool {
    /// åˆ›å»ºæ–°çš„ä¼šè¯æ± 
    pub fn new(config: SessionPoolConfig) -> Self {
        let pool = Self {
            idle_sessions: Arc::new(RwLock::new(BTreeMap::new())),
            next_seq: Arc::new(AtomicU64::new(1)),
            config,
            cleanup_task: Arc::new(Mutex::new(None)),
        };
        
        // å¯åŠ¨æ¸…ç†ä»»åŠ¡
        pool.start_cleanup_task();
        
        pool
    }
    
    /// è·å–æˆ–åˆ›å»ºä¼šè¯ï¼ˆä¼˜å…ˆä½¿ç”¨ Seq æœ€å¤§çš„ï¼‰
    pub async fn get_or_create<F, Fut>(
        &self,
        create_fn: F,
    ) -> Result<Arc<Session>>
    where
        F: FnOnce(u64) -> Fut,
        Fut: std::future::Future<Output = Result<Arc<Session>>>,
    {
        // 1. å°è¯•è·å– Seq æœ€å¤§çš„ç©ºé—²ä¼šè¯
        let session = {
            let mut sessions = self.idle_sessions.write().await;
            
            if let Some((seq, pooled)) = sessions.pop_last() {
                tracing::info!(
                    "[SessionPool] ğŸ”„ Reusing idle session (seq={})", 
                    seq
                );
                Some(pooled.session)
            } else {
                None
            }
        };
        
        if let Some(s) = session {
            return Ok(s);
        }
        
        // 2. åˆ›å»ºæ–°ä¼šè¯
        let seq = self.next_seq.fetch_add(1, Ordering::SeqCst);
        
        tracing::info!("[SessionPool] ğŸ†• Creating new session (seq={})", seq);
        
        let session = create_fn(seq).await?;
        
        // è®¾ç½® Session çš„ seq
        session.set_seq(seq);
        
        Ok(session)
    }
    
    /// å½’è¿˜ä¼šè¯åˆ°æ± ä¸­
    pub async fn return_session(&self, session: Arc<Session>) {
        let seq = session.seq();
        
        if session.is_closed() {
            tracing::warn!(
                "[SessionPool] âš ï¸ Not returning closed session (seq={})", 
                seq
            );
            return;
        }
        
        let pooled = PooledSession {
            seq,
            session,
            idle_since: Instant::now(),
        };
        
        tracing::info!("[SessionPool] ğŸ’¤ Returning session to pool (seq={})", seq);
        
        let mut sessions = self.idle_sessions.write().await;
        sessions.insert(seq, pooled);
    }
    
    /// å¯åŠ¨æ¸…ç†ä»»åŠ¡
    fn start_cleanup_task(&self) {
        let idle_sessions = self.idle_sessions.clone();
        let config = self.config.clone();
        
        let task = tokio::spawn(async move {
            loop {
                tokio::time::sleep(config.check_interval).await;
                
                Self::cleanup_expired_sessions(
                    &idle_sessions,
                    config.idle_timeout,
                    config.min_idle_sessions,
                ).await;
            }
        });
        
        // ä¿å­˜ä»»åŠ¡å¥æŸ„ï¼ˆå¯ç”¨äºå–æ¶ˆï¼‰
        let mut cleanup_task = self.cleanup_task.blocking_lock();
        *cleanup_task = Some(task);
    }
    
    /// æ¸…ç†è¿‡æœŸçš„ç©ºé—²ä¼šè¯
    async fn cleanup_expired_sessions(
        idle_sessions: &Arc<RwLock<BTreeMap<u64, PooledSession>>>,
        idle_timeout: Duration,
        min_idle: usize,
    ) {
        let now = Instant::now();
        let mut sessions = idle_sessions.write().await;
        
        let total_count = sessions.len();
        if total_count <= min_idle {
            // ä¸è¶³æœ€å°æ•°é‡ï¼Œä¸æ¸…ç†
            return;
        }
        
        // æ”¶é›†è¿‡æœŸçš„ seqï¼ˆä»æœ€è€çš„å¼€å§‹ï¼‰
        let mut to_remove = Vec::new();
        let mut kept_count = 0;
        
        for (seq, pooled) in sessions.iter().rev() {
            let idle_duration = now.duration_since(pooled.idle_since);
            
            if idle_duration > idle_timeout && kept_count >= min_idle {
                to_remove.push(*seq);
            } else {
                kept_count += 1;
            }
        }
        
        // ç§»é™¤è¿‡æœŸä¼šè¯
        for seq in &to_remove {
            if let Some(pooled) = sessions.remove(seq) {
                tracing::info!(
                    "[SessionPool] ğŸ—‘ï¸ Removed expired session (seq={}, idle={}s)",
                    seq,
                    now.duration_since(pooled.idle_since).as_secs()
                );
            }
        }
        
        if !to_remove.is_empty() {
            tracing::info!(
                "[SessionPool] ğŸ§¹ Cleanup: removed {}, kept {} sessions",
                to_remove.len(),
                sessions.len()
            );
        }
    }
}
```

#### 3.2 æ›´æ–° Session æ·»åŠ  seq å­—æ®µ (0.5 å¤©)

**æ–‡ä»¶**: `src/session/session.rs`

**æ·»åŠ **:

```rust
pub struct Session {
    // ... ç°æœ‰å­—æ®µ
    
    /// Session åºå·ï¼ˆç”¨äºä¼šè¯æ± ç®¡ç†ï¼‰
    seq: Arc<AtomicU64>,
}

impl Session {
    pub fn seq(&self) -> u64 {
        self.seq.load(Ordering::Acquire)
    }
    
    pub fn set_seq(&self, seq: u64) {
        self.seq.store(seq, Ordering::Release);
    }
}
```

#### 3.3 æ›´æ–° Client ä½¿ç”¨æ–°ä¼šè¯æ±  (0.5 å¤©)

**æ–‡ä»¶**: `src/client/client.rs`

**ä¿®æ”¹**:

```rust
impl Client {
    pub fn new(
        password: &str,
        server_addr: String,
        tls_config: Arc<tokio_rustls::TlsConnector>,
        padding: Arc<PaddingFactory>,
        pool_config: Option<SessionPoolConfig>,  // æ–°å¢å‚æ•°
    ) -> Self {
        let session_pool = Arc::new(
            SessionPool::new(pool_config.unwrap_or_default())
        );
        
        // ...
    }
    
    pub async fn create_stream(&self) -> Result<Arc<Session>> {
        self.session_pool.get_or_create(|seq| {
            self.create_new_session(seq)
        }).await
    }
    
    async fn create_new_session(&self, seq: u64) -> Result<Arc<Session>> {
        tracing::info!("[Client] Creating new session (seq={})", seq);
        
        // åˆ›å»º TLS è¿æ¥
        let session = /* ... */;
        
        session.set_seq(seq);
        
        Ok(session)
    }
}
```

#### 3.4 æ·»åŠ å‘½ä»¤è¡Œå‚æ•° (0.5 å¤©)

**æ–‡ä»¶**: `src/bin/client.rs`

**æ·»åŠ **:

```rust
use clap::Parser;

#[derive(Parser, Debug)]
struct Args {
    // ... ç°æœ‰å‚æ•°
    
    /// æ£€æŸ¥ç©ºé—²ä¼šè¯çš„é—´éš”æ—¶é—´ï¼ˆç§’ï¼‰
    #[arg(long, default_value = "30")]
    idle_check_interval: u64,
    
    /// ç©ºé—²ä¼šè¯è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
    #[arg(long, default_value = "60")]
    idle_timeout: u64,
    
    /// æœ€å°ä¿ç•™çš„ç©ºé—²ä¼šè¯æ•°
    #[arg(long, default_value = "1")]
    min_idle_sessions: usize,
}

fn main() {
    let args = Args::parse();
    
    let pool_config = SessionPoolConfig {
        check_interval: Duration::from_secs(args.idle_check_interval),
        idle_timeout: Duration::from_secs(args.idle_timeout),
        min_idle_sessions: args.min_idle_sessions,
    };
    
    let client = Client::new(
        &args.password,
        args.server,
        tls_config,
        padding,
        Some(pool_config),
    );
}
```

**ä¾èµ–**: æ·»åŠ  `clap` (å¦‚æœè¿˜æ²¡æœ‰)

```toml
[dependencies]
clap = { version = "4.4", features = ["derive"] }
```

#### 3.5 æµ‹è¯• (1 å¤©)

**æµ‹è¯•åœºæ™¯**:
- [ ] Seq å•è°ƒé€’å¢
- [ ] ä¼˜å…ˆå¤ç”¨æœ€æ–°ä¼šè¯
- [ ] è‡ªåŠ¨æ¸…ç†è¿‡æœŸä¼šè¯
- [ ] ä¿ç•™æœ€å°æ•°é‡
- [ ] é…ç½®å‚æ•°ç”Ÿæ•ˆ

**æµ‹è¯•æ–‡ä»¶**: `tests/session_pool.rs`

### éªŒæ”¶æ ‡å‡†

- [ ] âœ… Seq æ­£ç¡®è·Ÿè¸ªå’Œé€’å¢
- [ ] âœ… ä¼˜å…ˆä½¿ç”¨æœ€æ–°ä¼šè¯
- [ ] âœ… è‡ªåŠ¨æ¸…ç†è¿‡æœŸä¼šè¯
- [ ] âœ… é…ç½®å‚æ•°æ­£å¸¸å·¥ä½œ
- [ ] âœ… æµ‹è¯•é€šè¿‡

---

## ğŸŸ  é˜¶æ®µ 4: SYNACK è¶…æ—¶æ£€æµ‹ (1-2 å¤©) â­â­â­â˜†â˜†

**ç›®æ ‡**: å¿«é€Ÿæ£€æµ‹å‡ºç«™è¿æ¥å¤±è´¥

### ä»»åŠ¡åˆ†è§£

#### 4.1 æ·»åŠ  SYNACK ç­‰å¾…æœºåˆ¶ (0.5 å¤©)

**æ–‡ä»¶**: `src/session/stream.rs`

**æ·»åŠ **:

```rust
use tokio::sync::oneshot;

pub struct Stream {
    // ... ç°æœ‰å­—æ®µ
    
    /// SYNACK é€šçŸ¥ channel
    synack_tx: Option<oneshot::Sender<Result<()>>>,
    synack_rx: Option<oneshot::Receiver<Result<()>>>,
}

impl Stream {
    pub fn new(/* ... */) -> (Self, oneshot::Receiver<Result<()>>) {
        let (synack_tx, synack_rx) = oneshot::channel();
        
        let stream = Self {
            // ...
            synack_tx: Some(synack_tx),
            synack_rx: None,
        };
        
        (stream, synack_rx)
    }
    
    /// é€šçŸ¥æ”¶åˆ° SYNACK
    pub fn notify_synack(&mut self, result: Result<()>) {
        if let Some(tx) = self.synack_tx.take() {
            let _ = tx.send(result);
        }
    }
}
```

#### 4.2 Session å¤„ç† SYNACK (0.5 å¤©)

**æ–‡ä»¶**: `src/session/session.rs`

**ä¿®æ”¹**:

```rust
async fn handle_frame(&self, frame: Frame) -> Result<()> {
    match frame.cmd {
        Command::SynAck => {
            tracing::info!("[Session] ğŸ’š Received SYNACK for stream {}", frame.stream_id);
            
            let streams = self.streams.read().await;
            if let Some(stream) = streams.get(&frame.stream_id) {
                // æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯ä¿¡æ¯
                if frame.data.is_empty() {
                    // æˆåŠŸ
                    stream.notify_synack(Ok(()));
                } else {
                    // å¤±è´¥ï¼Œæºå¸¦é”™è¯¯ä¿¡æ¯
                    let error_msg = String::from_utf8_lossy(&frame.data).to_string();
                    stream.notify_synack(Err(AnyTlsError::RemoteError(error_msg)));
                }
            }
        }
        // ...
    }
}
```

#### 4.3 Client æ·»åŠ è¶…æ—¶ç­‰å¾… (0.5 å¤©)

**æ–‡ä»¶**: `src/client/client.rs`

**ä¿®æ”¹**:

```rust
pub async fn open_stream_with_timeout(
    &self,
    timeout: Duration,
) -> Result<Arc<Stream>> {
    let (stream, synack_rx) = self.session.open_stream_with_synack().await?;
    
    // ç­‰å¾… SYNACK æˆ–è¶…æ—¶
    tokio::select! {
        result = synack_rx => {
            match result {
                Ok(Ok(())) => {
                    tracing::info!("[Client] âœ… Stream opened successfully");
                    Ok(stream)
                }
                Ok(Err(e)) => {
                    tracing::error!("[Client] âŒ Stream open failed: {}", e);
                    stream.close().await;
                    Err(e)
                }
                Err(_) => {
                    tracing::error!("[Client] âŒ SYNACK channel closed");
                    Err(AnyTlsError::SessionClosed)
                }
            }
        }
        _ = tokio::time::sleep(timeout) => {
            tracing::error!("[Client] â° SYNACK timeout after {}s", timeout.as_secs());
            stream.close().await;
            Err(AnyTlsError::Timeout)
        }
    }
}
```

#### 4.4 æµ‹è¯•å’Œæ–‡æ¡£ (0.5 å¤©)

**æµ‹è¯•**:
- [ ] æ­£å¸¸ SYNACK æ¥æ”¶
- [ ] SYNACK æºå¸¦é”™è¯¯
- [ ] SYNACK è¶…æ—¶
- [ ] è¶…æ—¶åæ­£ç¡®æ¸…ç†

### éªŒæ”¶æ ‡å‡†

- [ ] âœ… æ­£å¸¸æƒ…å†µå¿«é€Ÿè¿”å›
- [ ] âœ… è¶…æ—¶èƒ½æ­£ç¡®æ£€æµ‹
- [ ] âœ… é”™è¯¯ä¿¡æ¯æ­£ç¡®ä¼ é€’
- [ ] âœ… èµ„æºæ­£ç¡®é‡Šæ”¾

---

## ğŸ”´ é˜¶æ®µ 5: ç‰ˆæœ¬åå•†æœºåˆ¶ (2-3 å¤©) â­â­â­â˜†â˜†

**ç›®æ ‡**: å®ç°å®Œæ•´çš„ v1/v2 åè®®åå•†

### ä»»åŠ¡åˆ†è§£

#### 5.1 æ·»åŠ ç‰ˆæœ¬çŠ¶æ€ (0.5 å¤©)

**æ–‡ä»¶**: `src/session/session.rs`

**æ·»åŠ **:

```rust
pub struct Session {
    // ... ç°æœ‰å­—æ®µ
    
    /// å®¢æˆ·ç«¯ä¸ŠæŠ¥çš„ç‰ˆæœ¬
    client_version: Arc<AtomicU8>,
    
    /// æœåŠ¡å™¨æ”¯æŒçš„ç‰ˆæœ¬
    server_version: Arc<AtomicU8>,
    
    /// åå•†åçš„å®é™…ç‰ˆæœ¬
    negotiated_version: Arc<AtomicU8>,
}

impl Session {
    /// è·å–åå•†åçš„ç‰ˆæœ¬
    pub fn negotiated_version(&self) -> u8 {
        self.negotiated_version.load(Ordering::Acquire)
    }
    
    /// æ£€æŸ¥æ˜¯å¦å¯ç”¨ v2 ç‰¹æ€§
    pub fn is_v2_enabled(&self) -> bool {
        self.negotiated_version() >= 2
    }
    
    /// è®¾ç½®å®¢æˆ·ç«¯ç‰ˆæœ¬
    pub fn set_client_version(&self, version: u8) {
        self.client_version.store(version, Ordering::Release);
        self.update_negotiated_version();
    }
    
    /// è®¾ç½®æœåŠ¡å™¨ç‰ˆæœ¬
    pub fn set_server_version(&self, version: u8) {
        self.server_version.store(version, Ordering::Release);
        self.update_negotiated_version();
    }
    
    /// æ›´æ–°åå•†ç‰ˆæœ¬ï¼ˆå–ä¸¤è€…æœ€å°å€¼ï¼‰
    fn update_negotiated_version(&self) {
        let client_ver = self.client_version.load(Ordering::Acquire);
        let server_ver = self.server_version.load(Ordering::Acquire);
        
        let negotiated = if client_ver == 0 || server_ver == 0 {
            // å°šæœªå®Œæˆåå•†
            0
        } else {
            std::cmp::min(client_ver, server_ver)
        };
        
        self.negotiated_version.store(negotiated, Ordering::Release);
        
        tracing::info!(
            "[Session] ğŸ¤ Version negotiated: client={}, server={}, using={}",
            client_ver,
            server_ver,
            negotiated
        );
    }
}
```

#### 5.2 å®¢æˆ·ç«¯ç‰ˆæœ¬åå•† (0.5 å¤©)

**æ–‡ä»¶**: `src/client/client.rs`

**ä¿®æ”¹**:

```rust
async fn start_session(&self) -> Result<Arc<Session>> {
    // 1. å»ºç«‹ TLS è¿æ¥
    let stream = TcpStream::connect(&self.server_addr).await?;
    let tls_stream = /* TLS æ¡æ‰‹ */;
    
    // 2. å‘é€è®¤è¯
    send_authentication(/* ... */).await?;
    
    // 3. åˆ›å»º Session
    let session = Session::new(/* ... */);
    
    // 4. å‘é€ Settingsï¼ˆä¸ŠæŠ¥å®¢æˆ·ç«¯ç‰ˆæœ¬ v=2ï¼‰
    let settings = StringMap::from([
        ("v", "2"),
        ("client", "anytls-rs/0.3.0"),
        ("padding-md5", &self.padding.md5()),
    ]);
    session.send_settings(settings).await?;
    
    // 5. ç­‰å¾… ServerSettingsï¼ˆå¸¦è¶…æ—¶ï¼‰
    tokio::select! {
        result = session.wait_server_settings() => {
            if let Some(server_version) = result? {
                session.set_server_version(server_version);
            } else {
                // æœªæ”¶åˆ° ServerSettingsï¼Œé»˜è®¤ v1
                session.set_server_version(1);
            }
        }
        _ = tokio::time::sleep(Duration::from_secs(5)) => {
            // è¶…æ—¶ï¼Œè®¤ä¸ºæ˜¯ v1 æœåŠ¡å™¨
            tracing::warn!("[Client] â° ServerSettings timeout, assuming v1");
            session.set_server_version(1);
        }
    }
    
    Ok(session)
}
```

#### 5.3 æœåŠ¡å™¨ç‰ˆæœ¬åå•† (0.5 å¤©)

**æ–‡ä»¶**: `src/server/server.rs`

**ä¿®æ”¹**:

```rust
async fn handle_connection(&self, stream: TcpStream) -> Result<()> {
    // 1-3. TLS æ¡æ‰‹ã€è®¤è¯ç­‰
    
    // 4. åˆ›å»º Session
    let session = Session::new(/* ... */);
    
    // 5. ç­‰å¾… Settingsï¼ˆè¯»å–å®¢æˆ·ç«¯ç‰ˆæœ¬ï¼‰
    let client_settings = session.wait_client_settings().await?;
    let client_version = client_settings.get("v")
        .and_then(|v| v.parse::<u8>().ok())
        .unwrap_or(1);
    
    session.set_client_version(client_version);
    
    // 6. å¦‚æœå®¢æˆ·ç«¯æ˜¯ v2ï¼Œå‘é€ ServerSettings
    if client_version >= 2 {
        let server_settings = StringMap::from([("v", "2")]);
        session.send_server_settings(server_settings).await?;
        session.set_server_version(2);
    } else {
        session.set_server_version(1);
    }
    
    // 7. å¼€å§‹ä¼šè¯å¾ªç¯
    session.run().await?;
    
    Ok(())
}
```

#### 5.4 æ¡ä»¶ç‰¹æ€§å¯ç”¨ (0.5 å¤©)

**æ–‡ä»¶**: `src/session/session.rs`

**ä¿®æ”¹æ‰€æœ‰ v2 ç‰¹æ€§ä½¿ç”¨**:

```rust
// SYNACK ç›¸å…³
if self.is_v2_enabled() {
    // å‘é€ SYNACK
}

// HeartRequest ç›¸å…³
if self.is_v2_enabled() {
    // å¤„ç†å¿ƒè·³
}
```

#### 5.5 æµ‹è¯• (1 å¤©)

**æµ‹è¯•åœºæ™¯**:
- [ ] v2 å®¢æˆ·ç«¯ + v2 æœåŠ¡å™¨ï¼ˆå¯ç”¨æ‰€æœ‰ç‰¹æ€§ï¼‰
- [ ] v2 å®¢æˆ·ç«¯ + v1 æœåŠ¡å™¨ï¼ˆé™çº§åˆ° v1ï¼‰
- [ ] v1 å®¢æˆ·ç«¯ + v2 æœåŠ¡å™¨ï¼ˆé™çº§åˆ° v1ï¼‰
- [ ] v1 å®¢æˆ·ç«¯ + v1 æœåŠ¡å™¨ï¼ˆv1 æ¨¡å¼ï¼‰

### éªŒæ”¶æ ‡å‡†

- [ ] âœ… ç‰ˆæœ¬æ­£ç¡®åå•†
- [ ] âœ… ç‰¹æ€§æ­£ç¡®å¯ç”¨/ç¦ç”¨
- [ ] âœ… å‘åå…¼å®¹ v1
- [ ] âœ… ä¸ Go äº’æ“ä½œ

---

## ğŸŸ£ é˜¶æ®µ 6: æ–‡æ¡£å’Œæµ‹è¯•å®Œå–„ (1-2 å¤©)

### ä»»åŠ¡

#### 6.1 æ›´æ–°æ–‡æ¡£

**æ–‡ä»¶**:
- `README.md`: æ›´æ–°åŠŸèƒ½åˆ—è¡¨ï¼Œæ·»åŠ  v0.3.0 ç‰¹æ€§
- `CHANGELOG.md`: æ·»åŠ  v0.3.0 å˜æ›´è®°å½•
- `ARCHITECTURE.md`: æ›´æ–°æ¶æ„è¯´æ˜
- `FEATURE_COMPARISON.md`: æ›´æ–°å¯¹æ¯”è¡¨

#### 6.2 å®Œå–„æµ‹è¯•

**æ–°å¢æµ‹è¯•**:
- `tests/heartbeat.rs`: å¿ƒè·³æœºåˆ¶æµ‹è¯•
- `tests/udp_over_tcp.rs`: UDP ä»£ç†æµ‹è¯•
- `tests/session_pool.rs`: ä¼šè¯æ± æµ‹è¯•
- `tests/version_negotiation.rs`: ç‰ˆæœ¬åå•†æµ‹è¯•

#### 6.3 ç«¯åˆ°ç«¯æµ‹è¯•

**æµ‹è¯•è„šæœ¬**: `test_v0.3.0.ps1`

```powershell
# å¿ƒè·³æµ‹è¯•
# UDP æµ‹è¯•
# ä¼šè¯å¤ç”¨æµ‹è¯•
# ç‰ˆæœ¬åå•†æµ‹è¯•
# ä¸ Go äº’æ“ä½œæµ‹è¯•
```

---

## æµ‹è¯•è®¡åˆ’

### å•å…ƒæµ‹è¯•

| æ¨¡å— | æµ‹è¯•æ•°é‡ | è¦†ç›–å†…å®¹ |
|------|---------|---------|
| heartbeat | 3-5 | è¯·æ±‚/å“åº”/è¶…æ—¶ |
| udp_proxy | 5-8 | ç¼–è§£ç /è½¬å‘/åœ°å€ |
| session_pool | 5-8 | Seq/æ¸…ç†/é…ç½® |
| version_negotiation | 4-6 | v1/v2 ç»„åˆ |

### é›†æˆæµ‹è¯•

- [ ] å®Œæ•´çš„å¿ƒè·³æµç¨‹
- [ ] UDP ä»£ç†ç«¯åˆ°ç«¯
- [ ] ä¼šè¯å¤ç”¨å’Œæ¸…ç†
- [ ] ç‰ˆæœ¬é™çº§åœºæ™¯

### äº’æ“ä½œæµ‹è¯•

- [ ] Rust å®¢æˆ·ç«¯ + Go æœåŠ¡å™¨
- [ ] Go å®¢æˆ·ç«¯ + Rust æœåŠ¡å™¨
- [ ] æ··åˆç‰ˆæœ¬åœºæ™¯

### æ€§èƒ½æµ‹è¯•

- [ ] UDP ååé‡
- [ ] ä¼šè¯å¤ç”¨æ•ˆç‡
- [ ] å¿ƒè·³å¼€é”€
- [ ] å†…å­˜ä½¿ç”¨

---

## éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½å®Œæ•´æ€§

- [ ] âœ… è¢«åŠ¨å¿ƒè·³å“åº”å·¥ä½œæ­£å¸¸
- [ ] âœ… UDP over TCP åŠŸèƒ½å®Œæ•´
- [ ] âœ… ä¼šè¯æ± ç®¡ç†å®Œå–„
- [ ] âœ… SYNACK è¶…æ—¶æ£€æµ‹æœ‰æ•ˆ
- [ ] âœ… ç‰ˆæœ¬åå•†æ­£ç¡®

### è´¨é‡æ ‡å‡†

- [ ] âœ… æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] âœ… æ‰€æœ‰é›†æˆæµ‹è¯•é€šè¿‡
- [ ] âœ… ä¸ Go äº’æ“ä½œæ­£å¸¸
- [ ] âœ… é›¶ç¼–è¯‘è­¦å‘Š
- [ ] âœ… Clippy æ£€æŸ¥é€šè¿‡

### æ€§èƒ½æ ‡å‡†

- [ ] âœ… ä¿æŒ +40-60% æ€§èƒ½ä¼˜åŠ¿
- [ ] âœ… UDP ååé‡ â‰¥ TCP
- [ ] âœ… å¿ƒè·³å¼€é”€ < 1% CPU
- [ ] âœ… å†…å­˜æ— æ³„æ¼

### æ–‡æ¡£æ ‡å‡†

- [ ] âœ… CHANGELOG æ›´æ–°
- [ ] âœ… README æ›´æ–°
- [ ] âœ… ARCHITECTURE æ›´æ–°
- [ ] âœ… API æ–‡æ¡£å®Œæ•´
- [ ] âœ… ä½¿ç”¨ç¤ºä¾‹å®Œå–„

---

## å®æ–½æ—¶é—´è¡¨

### ç¬¬ 1 å‘¨

| æ—¥æœŸ | ä»»åŠ¡ | çŠ¶æ€ |
|------|------|------|
| Day 1 | é˜¶æ®µ 1.1-1.2: å¿ƒè·³å“åº”æ ¸å¿ƒé€»è¾‘ | â³ |
| Day 2 | é˜¶æ®µ 1.3-1.4: å¿ƒè·³æµ‹è¯•å’Œæ–‡æ¡£ | â³ |
| Day 3 | é˜¶æ®µ 2.1-2.2: UDP åè®®ç ”ç©¶å’Œå®ç° | â³ |
| Day 4 | é˜¶æ®µ 2.2 ç»­: UDP ä»£ç†å®Œæˆ | â³ |
| Day 5 | é˜¶æ®µ 2.3-2.4: UDP é›†æˆ | â³ |

### ç¬¬ 2 å‘¨

| æ—¥æœŸ | ä»»åŠ¡ | çŠ¶æ€ |
|------|------|------|
| Day 6 | é˜¶æ®µ 2.5: UDP æµ‹è¯• | â³ |
| Day 7 | é˜¶æ®µ 3.1-3.2: ä¼šè¯æ± é‡æ„ | â³ |
| Day 8 | é˜¶æ®µ 3.3-3.4: Client é›†æˆ | â³ |
| Day 9 | é˜¶æ®µ 3.5: ä¼šè¯æ± æµ‹è¯• | â³ |
| Day 10 | é˜¶æ®µ 4: SYNACK å¢å¼º | â³ |

### ç¬¬ 3 å‘¨ï¼ˆå¯é€‰ï¼‰

| æ—¥æœŸ | ä»»åŠ¡ | çŠ¶æ€ |
|------|------|------|
| Day 11-12 | é˜¶æ®µ 5: ç‰ˆæœ¬åå•† | â³ |
| Day 13 | é˜¶æ®µ 6: æ–‡æ¡£å®Œå–„ | â³ |
| Day 14 | å…¨é¢æµ‹è¯•å’Œå‘å¸ƒå‡†å¤‡ | â³ |

---

## é£é™©è¯„ä¼°

### æŠ€æœ¯é£é™©

| é£é™© | æ¦‚ç‡ | å½±å“ | åº”å¯¹ç­–ç•¥ |
|------|------|------|---------|
| UDP åè®®å¤æ‚åº¦ | ä¸­ | é«˜ | æ·±å…¥ç ”ç©¶ Go å®ç° |
| ç‰ˆæœ¬å…¼å®¹æ€§é—®é¢˜ | ä¸­ | ä¸­ | å……åˆ†æµ‹è¯•å„ç§ç»„åˆ |
| æ€§èƒ½å›å½’ | ä½ | é«˜ | æŒç»­æ€§èƒ½æµ‹è¯• |

### è¿›åº¦é£é™©

| é£é™© | æ¦‚ç‡ | å½±å“ | åº”å¯¹ç­–ç•¥ |
|------|------|------|---------|
| å·¥ä½œé‡è¶…é¢„æœŸ | ä¸­ | ä¸­ | ä¼˜å…ˆå®æ–½ P0 ä»»åŠ¡ |
| ä¾èµ–é˜»å¡ | ä½ | ä½ | ä»»åŠ¡ç›¸å¯¹ç‹¬ç«‹ |

---

## ä¾èµ–ç®¡ç†

### æ–°å¢ä¾èµ–

```toml
[dependencies]
# å‘½ä»¤è¡Œå‚æ•°è§£æï¼ˆä¼šè¯æ± é…ç½®ï¼‰
clap = { version = "4.4", features = ["derive"] }

# UDP socketï¼ˆå·²æœ‰ tokioï¼‰
# tokio = { version = "1.36", features = ["net"] }

# æ—¶é—´å¤„ç†ï¼ˆå·²æœ‰ tokioï¼‰
# tokio = { version = "1.36", features = ["time"] }
```

### ç°æœ‰ä¾èµ–æ›´æ–°

æ— éœ€æ›´æ–°ï¼Œç°æœ‰ä¾èµ–è¶³å¤Ÿã€‚

---

## å‘å¸ƒæµç¨‹

### å‘å¸ƒå‰æ£€æŸ¥

- [ ] æ‰€æœ‰ P0 ä»»åŠ¡å®Œæˆ
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] æ–‡æ¡£æ›´æ–°å®Œæˆ
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] ä¸ Go äº’æ“ä½œæµ‹è¯•é€šè¿‡

### å‘å¸ƒæ­¥éª¤

```bash
# 1. æ›´æ–°ç‰ˆæœ¬å·
# Cargo.toml: version = "0.3.0"

# 2. æ›´æ–° CHANGELOG
# æ·»åŠ  v0.3.0 å˜æ›´è®°å½•

# 3. æäº¤
git add -A
git commit -m "chore: bump version to 0.3.0"

# 4. åˆ›å»ºæ ‡ç­¾
git tag -a v0.3.0 -m "Version 0.3.0: Feature parity with Go implementation

- Passive heartbeat response
- UDP over TCP support  
- Enhanced session pool management
- SYNACK timeout detection
- Version negotiation mechanism

Closes gap with Go implementation from 75% to 90%."

# 5. æ¨é€
git push origin master
git push origin v0.3.0

# 6. å‘å¸ƒåˆ° crates.ioï¼ˆå¯é€‰ï¼‰
cargo publish
```

---

## å›æ»šè®¡åˆ’

### æ¡ä»¶

ä»…åœ¨ä»¥ä¸‹æƒ…å†µå›æ»šï¼š
- ä¸¥é‡ bug æ— æ³•å¿«é€Ÿä¿®å¤
- æ€§èƒ½ä¸¥é‡ä¸‹é™ï¼ˆ>30%ï¼‰
- ä¸ Go äº’æ“ä½œå¤±è´¥

### æ­¥éª¤

```bash
# å›æ»šåˆ° v0.2.0
git revert v0.3.0
# æˆ–
git reset --hard v0.2.0
git push origin master --force  # æ…ç”¨
```

---

## ç›‘æ§æŒ‡æ ‡

### å¼€å‘è¿›åº¦

- å·²å®Œæˆä»»åŠ¡æ•° / æ€»ä»»åŠ¡æ•°
- æµ‹è¯•è¦†ç›–ç‡
- ä»£ç å®¡æŸ¥è¿›åº¦

### è´¨é‡æŒ‡æ ‡

- æµ‹è¯•é€šè¿‡ç‡
- Clippy è­¦å‘Šæ•°
- æ–‡æ¡£è¦†ç›–ç‡

### æ€§èƒ½æŒ‡æ ‡

- ååé‡å˜åŒ–
- å»¶è¿Ÿå˜åŒ–
- å†…å­˜ä½¿ç”¨å˜åŒ–

---

## å‚è€ƒèµ„æ–™

### åè®®æ–‡æ¡£

- `anytls-go/docs/protocol.md` - AnyTLS åè®®è§„èŒƒ
- `anytls-go/docs/uri_scheme.md` - URI æ ¼å¼
- sing-box udp-over-tcp v2 åè®®æ–‡æ¡£

### Go å®ç°å‚è€ƒ

- `anytls-go/proxy/session/session.go` - Session å®ç°
- `anytls-go/proxy/session/stream.go` - Stream å®ç°
- `anytls-go/cmd/server/outbound_tcp.go` - UDP ä»£ç†
- `anytls-go/cmd/client/myclient.go` - å®¢æˆ·ç«¯å®ç°

### å·²æœ‰æ–‡æ¡£

- `FEATURE_COMPARISON.md` - è¯¦ç»†åŠŸèƒ½å¯¹æ¯”
- `FEATURE_GAP_SUMMARY.md` - å·®è·æ€»ç»“
- `ARCHITECTURE.md` - æ¶æ„æ–‡æ¡£

---

## æ€»ç»“

### v0.3.0 å…³é”®é‡Œç¨‹ç¢‘

**ä»**:
- 75% åŠŸèƒ½å®Œæ•´åº¦
- æ ¸å¿ƒåŠŸèƒ½å®Œæ•´
- ç¼ºå°‘é«˜çº§ç‰¹æ€§

**åˆ°**:
- 90% åŠŸèƒ½å®Œæ•´åº¦
- é«˜çº§ç‰¹æ€§å®Œæ•´
- ä¸ Go å®ç°å¯¹ç­‰

### æ ¸å¿ƒä»·å€¼

1. **åŠŸèƒ½å®Œæ•´**: è¿½ä¸Š Go å®ç°
2. **æ€§èƒ½é¢†å…ˆ**: ä¿æŒ Rust ä¼˜åŠ¿
3. **ç¨³å®šå¯é **: å……åˆ†æµ‹è¯•éªŒè¯
4. **å‘åå…¼å®¹**: æ”¯æŒ v1 åè®®

### ä¸‹ä¸€æ­¥

**ç«‹å³å¼€å§‹**: é˜¶æ®µ 1 - è¢«åŠ¨å¿ƒè·³å“åº”ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼Œ1-2 å¤©ï¼‰

---

**åˆ¶å®šæ—¥æœŸ**: 2025-11-03  
**ç›®æ ‡å‘å¸ƒ**: 2025-11-17 (2 å‘¨å)  
**è´£ä»»äºº**: å¼€å‘å›¢é˜Ÿ

---

ğŸš€ **å‡†å¤‡å¥½å¼€å§‹ v0.3.0 å¼€å‘äº†å—ï¼Ÿ**

